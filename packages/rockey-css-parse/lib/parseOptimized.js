/**
 * --------------------------------------------------------------
 * --------------------------------------------------------------
 * NOTE this is autogenerated module. Does not change it manually
 * generated via: npm run optimize-parse
 * --------------------------------------------------------------
 * --------------------------------------------------------------
 */
import cssToJSON from './cssToJSON';
import createMixin from './mixins/createMixin';
import interpolateWithMixins from './mixins/interpolateWithMixins';
import * as classnames from './utils/classnames';
import RockeySyntaxError from './utils/RockeySyntaxError';
const isMedia = key => key.indexOf('@media') === 0;
const isKeyFrames = key => key.indexOf('@keyframes') === 0;
const isNot = key => key.indexOf(':not') === 0;
const isNotSupported = key =>
  key.indexOf('@charset') === 0 || key.indexOf('@import') === 0;
const NOT_REGEX = /\(([^\)]+)\)(.*)/;
const COMPONENT_SYMBOLS = /^[%+~A-Za-z0-9\-\_\(\)\:\"\'\]\=\^\.\#\[\s]+$/;
const isStartsWithModificator = raw => {
  return (
    0 === raw.indexOf('@media') ||
    0 === raw.indexOf('[') ||
    0 === raw.indexOf('@keyframes') ||
    0 === raw.indexOf('@charset') ||
    0 === raw.indexOf('@import') ||
    0 === raw.indexOf('@font-face') ||
    0 === raw.indexOf('::placeholder') ||
    0 === raw.indexOf('::after') ||
    0 === raw.indexOf('::before') ||
    0 === raw.indexOf('::first-letter') ||
    0 === raw.indexOf('::first-line') ||
    0 === raw.indexOf(':active') ||
    0 === raw.indexOf(':checked') ||
    0 === raw.indexOf(':disabled') ||
    0 === raw.indexOf(':empty') ||
    0 === raw.indexOf(':enabled') ||
    0 === raw.indexOf(':first-child') ||
    0 === raw.indexOf(':first-of-type') ||
    0 === raw.indexOf(':focus') ||
    0 === raw.indexOf(':hover') ||
    0 === raw.indexOf(':in-range') ||
    0 === raw.indexOf(':invalid') ||
    0 === raw.indexOf(':lang') ||
    0 === raw.indexOf(':last-child') ||
    0 === raw.indexOf(':last-of-type') ||
    0 === raw.indexOf(':link') ||
    0 === raw.indexOf(':not') ||
    0 === raw.indexOf(':nth-child') ||
    0 === raw.indexOf(':nth-last-child') ||
    0 === raw.indexOf(':nth-last-of-type') ||
    0 === raw.indexOf(':nth-of-type') ||
    0 === raw.indexOf(':only-of-type') ||
    0 === raw.indexOf(':only-child') ||
    0 === raw.indexOf(':optional') ||
    0 === raw.indexOf(':out-of-range') ||
    0 === raw.indexOf(':read-only') ||
    0 === raw.indexOf(':read-write') ||
    0 === raw.indexOf(':required') ||
    0 === raw.indexOf(':root') ||
    0 === raw.indexOf(':target') ||
    0 === raw.indexOf(':valid') ||
    0 === raw.indexOf(':visited')
  );
};
const shouldGenerateSelectors = parent => parent.type !== 'keyframes';
export default function createParser(config = {}) {
  const plugins = config.plugins || [];
  const actions = {
    // getClassName: classnames.getClassName(config.getClassName),
    getMixinClassName: classnames.getMixinClassName(config.getMixinClassName),
    // getSelector: classnames.getSelector(config.getClassName),
    getAnimationName: config.getAnimationName
      ? config.getAnimationName
      : name => name,
  };
  const getComponentName = classnames.getComponentName;
  return function parse(strings, ...values) {
    const context = {
      hasAnimations: false,
      animations: {},
      classnames: {
        components: {},
        selector: {},
      },
    };
    const classname = classnames.getClassName(config.getClassName);
    const getClassName = component => {
      if (context.classnames.components[component]) {
        return context.classnames.components[component];
      }
      const className = classname(component);
      context.classnames.components[component] = className;
      return className;
    };
    const selector = classnames.getSelector(getClassName);
    const getSelector = component => {
      if (context.classnames.selector[component]) {
        return context.classnames.selector[component];
      }
      const className = selector(component);
      context.classnames.selector[component] = className;
      return className;
    };
    let raw = null;
    let mixinsFunctions = {};
    if (values.length === 0) {
      raw = Array.isArray(strings) ? strings[0] : strings;
    } else {
      const interpolated = interpolateWithMixins(strings, ...values);
      raw = interpolated.raw;
      mixinsFunctions = interpolated.mixinsFunctions;
    }
    const inline = raw.replace(/\r|\n/g, '').replace(/\s+/g, ' ');
    let root = null;
    let precss = [];
    try {
      root = toPreCSS(inline, {
        type: 'root',
        selector: [],
        media: null,
        root: [],
      });
    } catch (e) {
      if (!e.rockeyError) {
        throw e;
      }
      // const [before, after] = context.raw.split(e.rule.trim());
      //
      // let desc = null;
      //
      // if (after) {
      //   desc = before.split(' ').slice(0, 5).join(' ') +
      //     e.rule +
      //     after.split(' ').slice(0, 5).join('');
      // } else {
      //   desc =  e.rule
      // }
      const desc = e.rule;
      const index = desc.indexOf(e.rule);
      const arrows = `${' '.repeat(index)}${'^'.repeat(e.rule.length)}`;
      throw new Error(
        `(rockey-css-parse) ${e.message}
${desc}
${arrows}
`
      );
    }
    return {
      classList: root.reduce((components, c) => {
        components[getComponentName(c)] = getClassName(c);
        return components;
      }, {}),
      precss,
    };
    function toPreCSS(raw, parent = {}) {
      let contextBackup = null;
      // if (context.raw) {
      //   contextBackup = context.raw;
      // }
      //
      // context.raw = raw;
      let openedBrackets = 0;
      let openedModificatorBrackets = 0;
      let styles = '';
      let rootComponents = [];
      let components = [];
      let possibleModificator = 0;
      let modificator = '';
      let current = '';
      let currentBackup = '';
      // ---
      const mixins = [];
      let possibleMixin = false;
      let mixin = '';
      let size = raw.length;
      let isComment = false;
      for (let i = 0; i < size; i++) {
        const symbol = raw[i];
        if (isComment) {
          if (symbol === '/' && raw[i - 1] === '*') {
            isComment = false;
          }
          continue;
        }
        if (symbol === '/' && raw[i + 1] === '*') {
          isComment = true;
          continue;
        }
        if (!!!components.length && !!!modificator) {
          if (symbol === '|') {
            possibleMixin = true;
          }
          if (possibleMixin) {
            if (symbol === ';' || symbol === ' ') {
              possibleMixin = false;
              if (parent.type === 'keyframes') {
                throw new Error(
                  '(rockey-css-parse) mixins inside keyframes are temporary disabled'
                );
              }
              const mixinFunction = createMixin({
                className: actions.getMixinClassName(mixinsFunctions[mixin]),
                selector: parent.selector,
                root: parent.root,
                func: mixinsFunctions[mixin],
                parse,
                plugins,
              });
              mixins.push(mixinFunction);
              current = current.replace(mixin, '');
              mixin = '';
              /* continue; */
            } else {
              mixin += symbol;
            }
          }
          if (
            !possibleModificator &&
            (symbol === '@' || symbol === ':' || symbol === '[') &&
            (s => !s.length || s.slice(-1) === ';' || s.slice(-1) === '{')(
              current.trim()
            )
          ) {
            possibleModificator = true;
            currentBackup = current;
            current = '';
          }
          if (possibleModificator && (symbol === '{' || symbol === ';')) {
            if (isStartsWithModificator(current.trim())) {
              modificator = current;
              current = '';
              if (isNotSupported(modificator)) {
                throw new Error(
                  '(rockey) @import and @charset are temporary not supported'
                );
              }
            } else {
              current = currentBackup + current;
              currentBackup = '';
            }
            possibleModificator = false;
            /* continue */
          }
        }
        if (
          !possibleModificator &&
          !!!modificator &&
          (symbol === '{' && openedBrackets === 0)
        ) {
          openedBrackets++;
          let i = null;
          for (i = current.length; i > 0; i--) {
            const symbol = current[i];
            if ((symbol === ':' || symbol === '[') && current[i - 1] === ' ') {
              throw new RockeySyntaxError(current);
            }
            if (
              symbol === ' ' &&
              (current[i - 1] === ':' || current[i - 1] === '[')
            ) {
              throw new RockeySyntaxError(current);
            }
            if (symbol === ';') {
              i++;
              break;
            }
          }
          let currentComponents = [];
          if (i) {
            styles += current.slice(0, i);
            currentComponents = current.slice(i).split(',');
          } else {
            currentComponents = current.split(',');
          }
          currentComponents.forEach(c => {
            components.push(c.trim());
          });
          current = '';
          // continue;
        } else if (symbol === '{') {
          if (!!components.length) {
            openedBrackets++;
            if (openedBrackets !== 1) {
              current += symbol;
            }
          } else if (!!modificator) {
            openedModificatorBrackets++;
            if (openedModificatorBrackets !== 1) {
              current += symbol;
            }
          }
        } else if (symbol === '}') {
          if (!!components.length) {
            openedBrackets--;
          } else if (!!modificator) {
            openedModificatorBrackets--;
          } else {
            throw new RockeySyntaxError(`${raw.slice(i - 1, i + 1)}`);
          }
          if (!!components.length) {
            if (openedBrackets === 0) {
              const selector = [];
              if (shouldGenerateSelectors(parent)) {
                components.forEach(c => {
                  if (process.env.NODE_ENV !== 'production') {
                    if (!COMPONENT_SYMBOLS.test(c)) {
                      throw new RockeySyntaxError(c);
                    }
                  }
                  rootComponents.push(c);
                  const className = getSelector(c);
                  if (parent.selector.length) {
                    parent.selector.forEach(p => {
                      selector.push(`${p} ${className}`);
                    });
                  } else {
                    selector.push(className);
                  }
                });
              }
              toPreCSS(current, {
                type: parent.type === 'keyframes' ? 'keyframes' : 'component',
                media: parent.media,
                root: parent.root.length ? parent.root : components,
                selector: parent.type === 'keyframes' ? components : selector,
              });
              components = [];
              current = '';
            } else {
              current += symbol;
            }
          } else if (!!modificator) {
            if (openedModificatorBrackets === 0) {
              modificator = modificator.trim();
              let selector = [];
              const media = isMedia(modificator);
              const keyframes = isKeyFrames(modificator);
              if (shouldGenerateSelectors(parent)) {
                if (media || keyframes) {
                  selector = [...parent.selector];
                } else {
                  modificator.split(',').forEach(m => {
                    m = m.trim();
                    if (isNot(m)) {
                      const matches = m.match(NOT_REGEX);
                      m = `:not(${getSelector(matches[1])})${matches[2]}`;
                    }
                    if (parent.selector.length) {
                      parent.selector.forEach(s => {
                        selector.push(s + m);
                      });
                    } else {
                      selector.push(m);
                    }
                  });
                }
              }
              if (media && parent.media) {
                throw new RockeySyntaxError(
                  modificator,
                  `@media should not be inside @media."${modificator}" inside "${parent.media}`
                );
              }
              if (keyframes) {
                if (parent.media) {
                  throw new RockeySyntaxError(
                    modificator,
                    `@keyframes should not be inside @media."${modificator}" inside "${parent.media}`
                  );
                }
                let animationName = modificator.split(' ')[1];
                let uniqAnimationName = actions.getAnimationName(animationName);
                if (context.animations[animationName]) {
                  throw new Error(
                    `(rockey-css-parse) duplicated keyframes "${animationName}"`
                  );
                }
                context.animations[animationName] = uniqAnimationName;
                context.hasAnimations = true;
                const backup = precss;
                precss = [];
                toPreCSS(current, {
                  selector: [],
                  type: 'keyframes',
                  root: parent.root,
                });
                backup.push({
                  selector: modificator.replace(
                    animationName,
                    uniqAnimationName
                  ),
                  frames: precss,
                });
                precss = backup;
              } else {
                toPreCSS(current, {
                  type: 'modificator',
                  media: media ? modificator : parent.media,
                  selector,
                  root: parent.root,
                });
              }
              modificator = '';
              current = currentBackup;
              currentBackup = '';
            } else {
              current += symbol;
            }
          }
        } else {
          current += symbol;
        }
      }
      current = currentBackup + current;
      currentBackup = '';
      if (current) {
        styles += current;
      }
      styles = styles.trim();
      if (!!modificator) {
        throw new RockeySyntaxError(modificator, 'not closed block');
      }
      if (!!components.length) {
        throw new RockeySyntaxError(components[0], 'not closed block');
      }
      if (styles || mixins.length) {
        if (parent.type !== 'keyframes' && !parent.selector.length) {
          throw new RockeySyntaxError(styles);
        }
        precss.push({
          selector: parent.selector,
          media: parent.media,
          root: parent.root,
          styles: styles ? cssToJSON(styles, context, plugins) : {},
          mixins,
        });
      }
      // if (contextBackup) {
      //   context.raw = contextBackup;
      // }
      return rootComponents;
    }
  };
}
